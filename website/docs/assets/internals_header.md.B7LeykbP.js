import{_ as n,C as e,o as s,c as i,a9 as a,E as r,w as l}from"./chunks/framework.DJOAND2c.js";const b=JSON.parse('{"title":"Header Character (16-bit Compression Metadata)","description":"","frontmatter":{},"headers":[],"relativePath":"internals/header.md","filePath":"internals/header.md","lastUpdated":1769694734000}'),c={name:"internals/header.md"};function h(p,t,g,m,y,u){const o=e("HeaderCharacter"),d=e("ClientOnly");return s(),i("div",null,[t[0]||(t[0]=a('<h1 id="header-character-16-bit-compression-metadata" tabindex="-1">Header Character (16-bit Compression Metadata) <a class="header-anchor" href="#header-character-16-bit-compression-metadata" aria-label="Permalink to &quot;Header Character (16-bit Compression Metadata)&quot;">​</a></h1><p>Every JSSC compressed string starts with a single <strong>UTF-16 character</strong> that stores all compression metadata required for decompression.</p><p>This character is called the <strong>Header Character</strong>.</p><p>It encodes the compression mode, flags, and mode-specific parameters entirely inside its <strong>16 bits</strong>, allowing the rest of the string to contain only compressed payload data.</p><h2 id="standard-bit-layout" tabindex="-1">Standard Bit Layout <a class="header-anchor" href="#standard-bit-layout" aria-label="Permalink to &quot;Standard Bit Layout&quot;">​</a></h2><p>Although each compression mode is free to interpret the 16 bits differently, most modes follow a <strong>standard layout</strong>.</p><p>Instead of viewing the header as four nibbles, JSSC groups bits into <strong>semantic blocks</strong>:</p>',7)),r(d,null,{default:l(()=>[r(o)]),_:1}),t[1]||(t[1]=a('<blockquote><table tabindex="0"><thead><tr><th style="text-align:right;">Name</th><th style="text-align:center;">Type</th><th>Meaning / Standart Usage</th></tr></thead><tbody><tr><td style="text-align:right;">Code #1</td><td style="text-align:center;">Integer</td><td>Compression Mode ID</td></tr><tr><td style="text-align:right;">Code #2</td><td style="text-align:center;">Integer</td><td>(Used by compression mode)</td></tr><tr><td style="text-align:right;">Code #3</td><td style="text-align:center;">Integer</td><td>Data type / JUSTC used? / BeginID</td></tr><tr><td style="text-align:right;">i?</td><td style="text-align:center;">Boolean</td><td>Input RLE used?</td></tr><tr><td style="text-align:right;">o?</td><td style="text-align:center;">Boolean</td><td>Output RLE used?</td></tr><tr><td style="text-align:right;">s?</td><td style="text-align:center;">Boolean</td><td>Sequences found &amp; compressed?</td></tr><tr><td style="text-align:right;">b?</td><td style="text-align:center;">Boolean</td><td>BeginID used? (<code>false</code> = Code #3 is BeginID)</td></tr></tbody></table></blockquote><h2 id="non-standard-layouts" tabindex="-1">Non-Standard Layouts <a class="header-anchor" href="#non-standard-layouts" aria-label="Permalink to &quot;Non-Standard Layouts&quot;">​</a></h2><p>The <strong>standard layout is not mandatory</strong>.</p><p>Some compression modes repurpose parts of the header to achieve better compression efficiency.</p><p>Whenever a mode deviates from the standard layout, this is explicitly documented on that mode’s page.</p>',5))])}const f=n(c,[["render",h]]);export{b as __pageData,f as default};
